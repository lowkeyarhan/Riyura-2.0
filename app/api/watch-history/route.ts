import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const VALID_STREAMS = new Set([
  "syntherionmovie",
  "ironlinkmovie",
  "dormannumovie",
  "nanovuemovie",
  "syntheriontv",
  "ironlinktv",
  "dormannutv",
  "nanovuetv",
]);

export async function GET(req: Request) {
  try {
    const authHeader = req.headers.get("Authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return NextResponse.json(
        { error: "Missing or Invalid Token" },
        { status: 401 }
      );
    }

    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      { global: { headers: { Authorization: authHeader } } }
    );

    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data, error } = await supabase
      .from("watch_history")
      .select("*")
      .eq("user_id", user.id)
      .order("watched_at", { ascending: false })
      .limit(10);

    if (error) throw error;

    return NextResponse.json({ success: true, data }, { status: 200 });
  } catch (err: any) {
    console.error("Error fetching watch history:", err.message);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

export async function POST(req: Request) {
  try {
    const authHeader = req.headers.get("Authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      console.warn(
        "‚ö†Ô∏è Watch History: Blocked request with missing/invalid token"
      );
      return NextResponse.json(
        { error: "Missing or Invalid Token" },
        { status: 401 }
      );
    }

    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      { global: { headers: { Authorization: authHeader } } }
    );

    const body = await req.json();
    const {
      user_id,
      tmdb_id,
      media_type,
      stream_id,
      title,
      poster_path,
      release_date,
      season_number,
      episode_number,
      episode_name,
      episode_length,
      duration_sec = 0,
    } = body;

    console.log(
      `üì• Watch History: Received update for [${media_type.toUpperCase()}] "${title}" (ID: ${tmdb_id})`
    );

    if (!user_id || !tmdb_id || !title || !media_type || !stream_id) {
      console.error("‚ùå Watch History: Missing required fields in payload");
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    if (!VALID_STREAMS.has(stream_id)) {
      console.error(`‚ùå Watch History: Invalid stream source: ${stream_id}`);
      return NextResponse.json({ error: "Invalid Stream ID" }, { status: 400 });
    }

    // 1. Check for existing record first
    const { data: existing } = await supabase
      .from("watch_history")
      .select("id, duration_sec, season_number, episode_number")
      .match({ user_id, tmdb_id, media_type })
      .maybeSingle();

    let finalDuration = duration_sec;

    // --- Duration Logic ---
    if (existing) {
      const isSameContext =
        media_type === "movie" ||
        (existing.season_number === season_number &&
          existing.episode_number === episode_number);

      if (isSameContext) {
        finalDuration += existing.duration_sec || 0;
        console.log(
          `‚è±Ô∏è  Accumulating time: ${existing.duration_sec}s + ${duration_sec}s = ${finalDuration}s`
        );
      } else {
        console.log(
          `üîÑ New Episode/Season detected (S${existing.season_number}E${existing.episode_number} -> S${season_number}E${episode_number}). Resetting duration.`
        );
      }
    } else {
      console.log("‚ú® Creating new watch record.");
    }

    const payload = {
      user_id,
      tmdb_id,
      media_type,
      stream_id,
      title,
      poster_path,
      release_date,
      season_number,
      episode_number,
      episode_name,
      episode_length,
      duration_sec: finalDuration,
      watched_at: new Date().toISOString(),
    };

    let query;

    if (existing?.id) {
      // Update existing record using ID selector
      console.log(`üìù Updating existing record (ID: ${existing.id})`);
      query = supabase
        .from("watch_history")
        .update(payload)
        .eq("id", existing.id);
    } else {
      // Insert new record (ID is generated by DB)
      console.log("‚ú® Inserting new record");
      query = supabase.from("watch_history").insert(payload);
    }

    const { data, error } = await query.select().single();

    if (error) {
      console.error("‚ùå Supabase Write Error:", error.message);
      throw error;
    }

    console.log(
      `‚úÖ Watch History: Successfully saved. Total Duration: ${finalDuration}s`
    );
    return NextResponse.json({ success: true, data }, { status: 200 });
  } catch (err: any) {
    console.error("üî• Critical Error in Watch History API:", err.message);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}
